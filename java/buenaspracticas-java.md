# ‚òï Gu√≠a de Buenas Pr√°cticas en Java Moderno (17+)

Este documento recopila las mejores pr√°cticas profesionales de c√≥digo Java pensadas para trabajar de forma eficaz con IAs generativas (GitHub Copilot, ChatGPT, Gemini, Claude): c√≥digo limpio, mantenible, robusto y f√°cil de sugerir por una IA.

---

## üìë Tabla de contenidos

- [üéØ Objetivo Pedag√≥gico](#-objetivo-pedag√≥gico)
- [üÜï Caracter√≠sticas de Java Moderno](#-caracter√≠sticas-de-java-moderno)
- [1Ô∏è‚É£ Records para DTOs y Value Objects](#1Ô∏è‚É£-records-para-dtos-y-value-objects)
- [2Ô∏è‚É£ Sealed Classes para Jerarqu√≠as Controladas](#2Ô∏è‚É£-sealed-classes-para-jerarqu√≠as-controladas)
- [3Ô∏è‚É£ Pattern Matching y Switch Expressions](#3Ô∏è‚É£-pattern-matching-y-switch-expressions)
- [4Ô∏è‚É£ Optional para Ausencia de Valores](#4Ô∏è‚É£-optional-para-ausencia-de-valores)
- [5Ô∏è‚É£ Streams y Programaci√≥n Funcional](#5Ô∏è‚É£-streams-y-programaci√≥n-funcional)
- [6Ô∏è‚É£ Try-with-Resources para Manejo de Recursos](#6Ô∏è‚É£-try-with-resources-para-manejo-de-recursos)
- [7Ô∏è‚É£ Un Solo Return + Guard Clauses](#7Ô∏è‚É£-un-solo-return--guard-clauses)
- [8Ô∏è‚É£ SRP: M√©todos Peque√±os con Una Responsabilidad](#8Ô∏è‚É£-srp-m√©todos-peque√±os-con-una-responsabilidad)
- [9Ô∏è‚É£ Javadoc Completo y √ötil](#9Ô∏è‚É£-javadoc-completo-y-√∫til)
- [üîü Excepciones Espec√≠ficas y Manejo Expl√≠cito](#-excepciones-espec√≠ficas-y-manejo-expl√≠cito)
- [üìã Prompt de Sistema para IAs Generativas (Java)](#-prompt-de-sistema-para-ias-generativas-java)
    - [ü§ñ C√≥mo Usar](#-c√≥mo-usar)
    - [üìÑ Versi√≥n Completa del Prompt](#-versi√≥n-completa-del-prompt)
    - [‚ö° Versi√≥n Corta del Prompt (Uso R√°pido)](#-versi√≥n-corta-del-prompt-uso-r√°pido)
- [‚úÖ Checklist de C√≥digo Java Profesional](#-checklist-de-c√≥digo-java-profesional)
- [üìö Referencias y Recursos](#-referencias-y-recursos)

---

## üéØ Objetivo Pedag√≥gico

Java moderno (17+) ha evolucionado notablemente. Si adoptas sus herramientas modernas:

- ‚úÖ M√°s conciso sin perder seguridad de tipos
- ‚úÖ M√°s legible y expresivo
- ‚úÖ M√°s robusto con pattern matching y sealed classes
- ‚úÖ M√°s f√°cil de entender para IAs generativas


---

## üÜï Caracter√≠sticas de Java Moderno

- Java 17 LTS: Records, Sealed Classes, Pattern Matching
- Java 21 LTS: Virtual Threads, Pattern Matching mejorado
- Java 23+: Iteraciones sobre pattern matching y librer√≠as

Requisito m√≠nimo recomendado: Java 17 (ideal: Java 21 LTS).

---

## 1Ô∏è‚É£ Records para DTOs y Value Objects

### ‚úÖ Usa Records (Java 16+)

Los `record` son clases inmutables perfectas para DTOs, value objects y resultados de queries.

```java
// ‚úÖ BIEN: Record conciso y claro
public record Usuario(
    String nombre,
    String email,
    int edad
) {}

// Uso autom√°tico: equals, hashCode, toString, getters
Usuario user = new Usuario("Ana", "ana@example.com", 25);
System.out.println(user.nombre());  // Getter autom√°tico
System.out.println(user);           // ToString autom√°tico
```

```java
// ‚ùå MAL: Clase verbosa tradicional
public class UsuarioViejo {
    private final String nombre;
    private final String email;
    private final int edad;
    
    public UsuarioViejo(String nombre, String email, int edad) {
        this.nombre = nombre;
        this.email = email;
        this.edad = edad;
    }
    
    public String getNombre() { return nombre; }
    public String getEmail() { return email; }
    public int getEdad() { return edad; }
    
    @Override public boolean equals(Object o) { /* 15 l√≠neas m√°s */ }
    @Override public int hashCode() { /* 5 l√≠neas m√°s */ }
    @Override public String toString() { /* 3 l√≠neas m√°s */ }
}
// ~50 l√≠neas vs 5 con record
```

### üéØ Records con Validaci√≥n

```java
// ‚úÖ BIEN: Record con validaci√≥n
public record Email(String valor) {
    public Email {
        if (valor == null || !valor.contains("@")) {
            throw new IllegalArgumentException("Email inv√°lido: " + valor);
        }
    }
}

// Uso
Email email = new Email("usuario@example.com");   // ‚úÖ OK
Email invalido = new Email("mal-email");          // ‚ùå Lanza excepci√≥n
```

---

## 2Ô∏è‚É£ Sealed Classes para Jerarqu√≠as Controladas

### ‚úÖ Usa Sealed Classes (Java 17+)

Las `sealed` classes permiten controlar qu√© clases pueden extenderlas, perfecto para modelar estados o tipos de resultados.

```java
// ‚úÖ BIEN: Sealed class con Result Type Pattern
public sealed interface Resultado<T> permits Exito, Error {}
public record Exito<T>(T valor) implements Resultado<T> {}
public record Error<T>(String mensaje, Throwable causa) implements Resultado<T> {}

// Uso con pattern matching
Resultado<String> resultado = obtenerDatos();
String mensaje = switch (resultado) {
    case Exito<String>(var valor) -> "√âxito: " + valor;
    case Error<String>(var msg, var causa) -> "Error: " + msg;
};
```

```java
// ‚ùå MAL: Jerarqu√≠a abierta con instanceof
public interface ResultadoViejo {}
public class ExitoViejo implements ResultadoViejo { public Object valor; }
public class ErrorViejo implements ResultadoViejo { public String mensaje; }

// Uso verboso y propenso a errores
ResultadoViejo r = obtenerDatos();
if (r instanceof ExitoViejo ex) {
    System.out.println(ex.valor);
} else if (r instanceof ErrorViejo er) {
    System.out.println(er.mensaje);
}
// ¬øQu√© pasa si alguien crea OtroTipoDeResultado?
```

---

## 3Ô∏è‚É£ Pattern Matching y Switch Expressions

```java
// ‚úÖ BIEN: Pattern matching con switch expression
public String procesarEntrada(Object entrada) {
    return switch (entrada) {
        case String s   -> "Texto: " + s.toUpperCase();
        case Integer i  -> "N√∫mero: " + (i * 2);
        case List<?> xs -> "Lista con " + xs.size() + " elementos";
        case null       -> "Entrada nula";
        default         -> "Tipo desconocido: " + entrada.getClass().getName();
    };
}
```

```java
// ‚ùå MAL: instanceof en cascada con casts
public String procesarEntradaViejo(Object entrada) {
    if (entrada instanceof String) {
        String s = (String) entrada;
        return "Texto: " + s.toUpperCase();
    } else if (entrada instanceof Integer) {
        Integer i = (Integer) entrada;
        return "N√∫mero: " + (i * 2);
    } else if (entrada instanceof List) {
        List<?> lista = (List<?>) entrada;
        return "Lista con " + lista.size() + " elementos";
    } else if (entrada == null) {
        return "Entrada nula";
    } else {
        return "Tipo desconocido: " + entrada.getClass().getName();
    }
}
```

---

## 4Ô∏è‚É£ Optional para Ausencia de Valores

```java
// ‚úÖ BIEN: Optional con API fluida
public Optional<Usuario> buscarUsuario(String email) {
    return repository.findByEmail(email);
}

String nombre = buscarUsuario("ana@example.com")
    .map(Usuario::nombre)
    .orElse("Usuario no encontrado");

// Guard clause
Optional<Usuario> u = buscarUsuario("ana@example.com");
if (u.isEmpty()) { throw new UsuarioNoEncontradoException("Usuario no existe"); }
Usuario usuario = u.get();
```

```java
// ‚ùå MAL: Retornar null
public Usuario buscarUsuarioViejo(String email) {
    Usuario usuario = repository.findByEmail(email);
    return usuario;  // Puede ser null ‚ùå
}
```

---

## 5Ô∏è‚É£ Streams y Programaci√≥n Funcional

```java
// ‚úÖ BIEN: Stream API
List<Usuario> usuarios = repository.findAll();
List<String> emailsActivos = usuarios.stream()
    .filter(u -> u.edad() >= 18)
    .filter(Usuario::activo)
    .map(Usuario::email)
    .sorted()
    .toList();

int sumaEdades = usuarios.stream()
    .filter(Usuario::activo)
    .mapToInt(Usuario::edad)
    .sum();
```

```java
// ‚ùå MAL: Imperativo
List<String> emailsActivos = new ArrayList<>();
for (Usuario u : usuarios) {
    if (u.edad() >= 18 && u.activo()) {
        emailsActivos.add(u.email());
    }
}
Collections.sort(emailsActivos);
```

---

## 6Ô∏è‚É£ Try-with-Resources para Manejo de Recursos

```java
// ‚úÖ BIEN: Try-with-resources
public List<String> leerArchivo(String ruta) throws IOException {
    try (var reader = Files.newBufferedReader(Path.of(ruta))) {
        return reader.lines().filter(l -> !l.isBlank()).toList();
    }
}

// Con base de datos
public List<Usuario> consultarUsuarios() throws SQLException {
    String sql = "SELECT * FROM usuarios WHERE activo = true";
    try (Connection conn = dataSource.getConnection();
         PreparedStatement stmt = conn.prepareStatement(sql);
         ResultSet rs = stmt.executeQuery()) {
        List<Usuario> usuarios = new ArrayList<>();
        while (rs.next()) {
            usuarios.add(new Usuario(
                rs.getString("nombre"), rs.getString("email"), rs.getInt("edad")));
        }
        return usuarios;
    }
}
```

---

## 7Ô∏è‚É£ Un Solo Return + Guard Clauses

Principio: UN m√©todo = UN solo return. Usa validaciones planas (if-else), evita la pir√°mide.

```java
// ‚úÖ BIEN: Guard clauses con UN SOLO return
public Resultado<Usuario> crearUsuario(String nombre, String email, int edad) {
    Resultado<Usuario> resultado;
    if (nombre == null || nombre.isBlank()) {
        resultado = new Error<>("Nombre requerido", null);
    } else if (email == null || !email.contains("@")) {
        resultado = new Error<>("Email inv√°lido", null);
    } else if (edad < 18) {
        resultado = new Error<>("Usuario debe ser mayor de edad", null);
    } else {
        Usuario usuario = new Usuario(nombre, email, edad);
        repository.save(usuario);
        resultado = new Exito<>(usuario);
    }
    return resultado;  // ‚úÖ UN SOLO RETURN
}
```

```java
// ‚ùå MAL: Pir√°mide de la muerte
public Resultado<Usuario> crearUsuarioViejo(String nombre, String email, int edad) {
    if (nombre != null && !nombre.isBlank()) {
        if (email != null && email.contains("@")) {
            if (edad >= 18) {
                Usuario usuario = new Usuario(nombre, email, edad);
                repository.save(usuario);
                return new Exito<>(usuario);
            } else {
                return new Error<>("Usuario debe ser mayor de edad", null);
            }
        } else {
            return new Error<>("Email inv√°lido", null);
        }
    } else {
        return new Error<>("Nombre requerido", null);
    }
}
```

---

## 8Ô∏è‚É£ SRP: M√©todos Peque√±os con Una Responsabilidad

```java
// ‚úÖ BIEN: M√©todos peque√±os con UN SOLO return cada uno
public class ServicioUsuario {
    public Resultado<Usuario> procesarRegistro(DatosRegistro datos) {
        Resultado<Usuario> resultado;
        Optional<DatosRegistro> validacion = validarDatos(datos);
        if (validacion.isEmpty()) {
            resultado = new Error<>("Datos inv√°lidos", null);
        } else {
            Usuario usuario = crearUsuario(datos);
            enviarEmailBienvenida(usuario);
            registrarEvento("USUARIO_CREADO", usuario.email());
            resultado = new Exito<>(usuario);
        }
        return resultado;  // ‚úÖ UN SOLO RETURN
    }

    private Optional<DatosRegistro> validarDatos(DatosRegistro datos) {
        Optional<DatosRegistro> resultado;
        if (datos.email() == null || !datos.email().contains("@")) {
            resultado = Optional.empty();
        } else {
            resultado = Optional.of(datos);
        }
        return resultado;  // ‚úÖ UN SOLO RETURN
    }

    private Usuario crearUsuario(DatosRegistro datos) {
        Usuario resultado = repository.save(new Usuario(
            datos.nombre(), datos.email(), datos.edad()));
        return resultado;  // ‚úÖ UN SOLO RETURN
    }

    private void enviarEmailBienvenida(Usuario usuario) {
        emailService.enviar(usuario.email(), "Bienvenido", "Gracias por registrarte");
    }

    private void registrarEvento(String tipo, String detalle) {
        auditService.log(tipo, detalle);
    }
}
```

---

## 9Ô∏è‚É£ Javadoc Completo y √ötil

```java
// ‚úÖ BIEN: Javadoc completo
/**
 * Busca un usuario por su direcci√≥n de email.
 *
 * @param email la direcci√≥n de email del usuario (debe contener '@')
 * @return Optional con el usuario si existe, Optional.empty() si no
 * @throws IllegalArgumentException si el email es null o inv√°lido
 * @throws RepositoryException si hay error de conexi√≥n con la base de datos
 */
public Optional<Usuario> buscarPorEmail(String email) {
    if (email == null || !email.contains("@")) {
        throw new IllegalArgumentException("Email inv√°lido: " + email);
    }
    return repository.findByEmail(email);
}
```

---

## üîü Excepciones Espec√≠ficas y Manejo Expl√≠cito

```java
// ‚úÖ BIEN: Excepciones espec√≠ficas con UN SOLO return
public class UsuarioNoEncontradoException extends RuntimeException {
    public UsuarioNoEncontradoException(String email) {
        super("Usuario no encontrado con email: " + email);
    }
}

public class EmailDuplicadoException extends RuntimeException {
    public EmailDuplicadoException(String email) {
        super("Ya existe un usuario con email: " + email);
    }
}

public Usuario buscarUsuario(String email) {
    Usuario resultado = repository.findByEmail(email)
        .orElseThrow(() -> new UsuarioNoEncontradoException(email));
    return resultado;  // ‚úÖ UN SOLO RETURN
}

public Usuario crearUsuario(DatosRegistro datos) {
    Usuario resultado;
    if (repository.existsByEmail(datos.email())) {
        throw new EmailDuplicadoException(datos.email());
    } else {
        resultado = repository.save(new Usuario(
            datos.nombre(), datos.email(), datos.edad()));
    }
    return resultado;  // ‚úÖ UN SOLO RETURN
}
```

---

## üìã Prompt de Sistema para IAs Generativas (Java)

### ü§ñ C√≥mo Usar

Usa la versi√≥n completa para proyectos serios y la corta para prompts r√°pidos.

### üìÑ Versi√≥n Completa del Prompt

````markdown
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üîΩ INICIO DEL PROMPT - Copia desde aqu√≠ üîΩ
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Prompt de Sistema para Generaci√≥n de C√≥digo Java Profesional

Eres un asistente de programaci√≥n Java especializado en c√≥digo limpio, moderno y profesional.

## Reglas OBLIGATORIAS para Java 17+:

1. **Records para DTOs y Value Objects**:
   - ‚úÖ Usa `record` para clases inmutables de datos
   - ‚úÖ A√±ade validaciones en constructor compacto si es necesario
   - ‚ùå NO uses clases verbosas con getters/setters/equals/hashCode manuales

1. **Sealed Classes para Jerarqu√≠as Controladas**:
   - ‚úÖ Usa `sealed interface/class` para tipos conocidos y limitados
   - ‚úÖ Combina con pattern matching en switch expressions
   - ‚ùå NO uses jerarqu√≠as abiertas con instanceof en cascada

1. **Pattern Matching y Switch Expressions**:
   - ‚úÖ Usa pattern matching con `switch` y `instanceof`
   - ‚úÖ Usa switch expressions (retornan valor)
   - ‚ùå NO uses if-else con instanceof y casts manuales

1. **Optional en lugar de null**:
   - ‚úÖ Retorna `Optional<T>` cuando un valor puede estar ausente
   - ‚úÖ Usa API fluida: `.map()`, `.filter()`, `.orElse()`, `.orElseThrow()`
   - ‚ùå NO retornes null ni uses null checks manuales

1. **Streams API**:
   - ‚úÖ Usa streams para operaciones sobre colecciones
   - ‚úÖ Prefiere declarativo sobre imperativo
   - ‚ùå NO uses loops for/while para transformaciones simples

1. **Try-with-Resources**:
   - ‚úÖ Usa try-with-resources para TODOS los recursos (Connection, Stream, Reader)
   - ‚úÖ Usa `var` para reducir verbosidad
   - ‚ùå NO cierres recursos manualmente con finally

1. **UN SOLO Return + Guard Clauses**:
   - ‚úÖ Cada m√©todo tiene UN √öNICO punto de retorno
   - ‚úÖ Usa if-else planas para validaciones (no anidadas)
   - ‚úÖ Declara variable de resultado al inicio
   - ‚ùå NO uses m√∫ltiples `return` en diferentes lugares
   - ‚ùå NO uses if-else anidados (pir√°mide de la muerte)

1. **Single Responsibility Principle**:
   - ‚úÖ Cada m√©todo hace UNA cosa
   - ‚úÖ M√©todos de 10-20 l√≠neas m√°ximo
   - ‚úÖ Nombres descriptivos que explican el prop√≥sito
   - ‚ùå NO crees m√©todos que hagan validaci√≥n + l√≥gica + email + logging

1. **Javadoc Completo**:
   ```java
   /**
    * Descripci√≥n breve del m√©todo.
    *
    * @param parametro descripci√≥n del par√°metro
    * @return descripci√≥n del valor de retorno
    * @throws TipoExcepcion cu√°ndo y por qu√© se lanza
    */
   ```

1. **Excepciones Espec√≠ficas**:
    - ‚úÖ Crea excepciones custom por tipo de error
    - ‚úÖ Mensajes descriptivos con contexto
    - ‚ùå NO uses Exception/RuntimeException gen√©ricas

## Ejemplos de C√≥digo CORRECTO:

```java
// Record con validaci√≥n
public record Email(String valor) {
    public Email {
        if (valor == null || !valor.contains("@")) {
            throw new IllegalArgumentException("Email inv√°lido: " + valor);
        }
    }
}

// Sealed class con pattern matching
public sealed interface Resultado<T> permits Exito, Error {}
public record Exito<T>(T valor) implements Resultado<T> {}
public record Error<T>(String mensaje) implements Resultado<T> {}

// Uso
String resultado = switch (operacion) {
    case Exito<String>(var valor) -> "OK: " + valor;
    case Error<String>(var msg) -> "Error: " + msg;
};

// UN SOLO return con guard clauses
public Resultado<Usuario> validar(String email) {
    Resultado<Usuario> resultado;
    if (email == null || email.isBlank()) {
        resultado = new Error<>("Email vac√≠o", null);
    } else if (!email.contains("@")) {
        resultado = new Error<>("Email inv√°lido", null);
    } else {
        Usuario usuario = repository.findByEmail(email);
        resultado = new Exito<>(usuario);
    }
    return resultado;  // UN SOLO RETURN
}
```

## IMPORTANTE

- Java 17 LTS es el m√≠nimo
- UN m√©todo = UN solo return (facilita debugging y comprensi√≥n de IAs)
- C√≥digo que una IA pueda entender y modificar f√°cilmente
- Prioriza legibilidad sobre brevedad
- Si tienes duda entre tradicional y moderno, elige moderno

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üîº FIN DEL PROMPT - Copia hasta aqu√≠ üîº
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
````

---

### ‚ö° Versi√≥n Corta del Prompt (Uso R√°pido)

````markdown
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üîΩ INICIO DEL PROMPT CORTO - Copia desde aqu√≠ üîΩ
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Genera c√≥digo Java 17+ profesional siguiendo estas reglas:
1) Records para DTOs (no clases con getters/setters)
2) Sealed classes + pattern matching (no instanceof)
3) Optional<T> en lugar de null
4) Streams API (no loops imperativos)
5) Try-with-resources para TODO recurso
6) UN SOLO return por m√©todo (validaciones planas)
7) M√©todos 10‚Äì20 l√≠neas, una responsabilidad
8) Javadoc completo (@param, @return, @throws)
9) Excepciones espec√≠ficas (no RuntimeException gen√©rica)

Ejemplo:
```java
public record Email(String valor) {
    public Email {
        if (valor == null || !valor.contains("@")) {
            throw new IllegalArgumentException("Email inv√°lido");
        }
    }
}

public Resultado<Usuario> validar(String email) {
    Resultado<Usuario> resultado;
    if (email == null) { resultado = new Error<>("Email nulo", null); }
    else { resultado = new Exito<>(repository.findByEmail(email).orElse(null)); }
    return resultado;  // UN SOLO RETURN
}
```

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üîº FIN DEL PROMPT CORTO - Copia hasta aqu√≠ üîº
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
````

---

## ‚úÖ Checklist de C√≥digo Java Profesional

- [ ] ¬øUs√© `record` para DTOs y value objects?
- [ ] ¬øUs√© `sealed class/interface` para jerarqu√≠as controladas?
- [ ] ¬øUs√© `Optional<T>` en lugar de `null`?
- [ ] ¬øUs√© pattern matching con switch expressions?
- [ ] ¬øUs√© Streams API?
- [ ] ¬øUs√© try-with-resources para TODOS los recursos?
- [ ] ¬øCre√© excepciones espec√≠ficas con mensajes con contexto?
- [ ] ¬øCada m√©todo tiene UN SOLO return? (sin m√∫ltiples returns)
- [ ] ¬øUs√© guard clauses (if-else planas) en lugar de anidar?
- [ ] ¬øCada m√©todo hace UNA sola cosa y < 20‚Äì30 l√≠neas?
- [ ] ¬øLos nombres de m√©todos/variables son descriptivos?
- [ ] ¬øCada m√©todo p√∫blico tiene Javadoc completo?

---

## üìö Referencias y Recursos

- [JEP 395: Records](https://openjdk.org/jeps/395) ‚Äî Java 16
- [JEP 409: Sealed Classes](https://openjdk.org/jeps/409) ‚Äî Java 17
- [JEP 441: Pattern Matching for switch](https://openjdk.org/jeps/441) ‚Äî Java 21
- [Java 17 LTS](https://docs.oracle.com/en/java/javase/17/)
- [Java 21 LTS](https://docs.oracle.com/en/java/javase/21/)
- Effective Java (3rd Ed.) ‚Äî Joshua Bloch
- Modern Java in Action ‚Äî Raoul-Gabriel Urma
- Clean Code ‚Äî Robert C. Martin

---

## üìò Sobre esta gu√≠a

Esta gu√≠a forma parte del repositorio **Buenas Pr√°cticas y Prompts para IAs de Programaci√≥n**.

üëâ **Ver m√°s gu√≠as**: [Repositorio completo](../README.md)

---

**Autor**: [David Bueno Vallejo](https://davidbuenov.com/) | [LinkedIn](https://www.linkedin.com/in/davidbueno/) | [GitHub](https://github.com/davidbuenov)

**Licencia**: MIT
